#!/usr/bin/env bash
#####################################################################################
##
## NOTE:
## This is a command line tool to operate on otomi-core.
## All commands are executed in docker container.
## Keep this file as simple as possible:
## - do not depend on any external files.
## - do not use any non standard tooling.
## - only Docker is needed to run otomi-core image
## If you need to use any extra binaries then most probably you want to add them to the otomi/tools image.
##
#####################################################################################
# shellcheck disable=SC2128
[ "${BASH_VERSINFO:-0}" -lt 4 ] && echo "You are using $BASH_VERSINFO, while we only support Bash -ge than version 4. Please upgrade." && exit 1
if [ -n "$TESTING" ]; then
  CI=1
  ENV_DIR="$PWD/tests/fixtures"
elif [ -z "$ENV_DIR" ]; then
  if [ ! "$(ls -A $PWD)" ]; then
    export ENV_DIR=$PWD
  elif [ -f "$PWD/env/cluster.yaml" ] && [ -f "$PWD/env/settings.yaml" ] && [ -d "$PWD/env/charts" ]; then
    export ENV_DIR=$PWD
  else
    echo -e "ENV_DIR is not set, otomi needs ENV_DIR to function. \nENV_DIR can be a (yet) non-existing path, but needs to be an absolute path." && exit 1
  fi
else
  mkdir -p $ENV_DIR
fi
this_is_bash=$(ps -o ppid= $$)
executing_shell=$(ps -o comm= $this_is_bash | sed "s/[^[:alnum:]\/]//g")
path_to_exec_shell=$(which $executing_shell)
# TODO: change image tag to latest
OTOMI_TAG=${OTOMI_TAG:-otomi-zx}
readonly otomi_tools_image="otomi/core:${OTOMI_TAG}"
# shellcheck disable=SC2155
readonly base_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
readonly calling_args="$*"
script_full_path="$base_dir/${BASH_SOURCE[0]##*/}"
if [[ ${BASH_SOURCE[0]} == '/'* ]]; then
  script_full_path="${BASH_SOURCE[0]}"
fi
readonly script_full_path

update_base="https://raw.githubusercontent.com/redkubes/otomi-core/${OTOMI_TAG}/binzx/otomi"

run_self_update() {
  echo "Performing self-update..."

  # Download new version
  echo -n "Downloading latest version..."
  if ! wget --quiet --output-document="$0.tmp" $update_base; then
    echo "Failed: Error while trying to wget new version!"
    echo "File requested: $update_base"
    exit 1
  fi
  echo "Done."

  # Copy over modes from old version
  OCTAL_MODE=$(stat -c '%a' $script_full_path)
  if ! chmod $OCTAL_MODE "$0.tmp"; then
    echo "Failed: Error while trying to set mode on $0.tmp."
    exit 1
  fi

  # Spawn update script
  cat >update-otomi.sh <<EOF
#!/bin/bash
# Overwrite old file with new
if mv "$0.tmp" "$0"; then
  echo "Done. Update complete."
  rm \$0
  exec "$0" "$calling_args"
else
  echo "Failed!"
fi
EOF

  echo -n "Inserting update process..."
  exec /bin/bash update-otomi.sh
}

check_update() {
  if [[ $base_dir == *"otomi-core"* ]] ||
    [[ $(pwd) == *"otomi-core"* ]] ||
    [[ $calling_args == *'-no-interactive'* ]] ||
    [[ $calling_args == *'-ni'* ]]; then
    return 0
  fi

  last_commit_date=$(curl -s "https://api.github.com/repos/redkubes/otomi-core/commits?sha=${OTOMI_TAG}&path=binzx%2Fotomi&page=1&per_page=1" | grep -A5 '"committer":' | grep '"date":' | awk -F': ' '{print $2}')
  last_file_change=$(date -u -r $script_full_path "+%Y-%m-%dT%H:%M:%SZ")
  last_commit_date=$(echo $last_commit_date | tr -d '"')
  last_commit_date_sec=$(date --date="$last_commit_date" +%s)
  last_file_change_sec=$(date --date="$last_file_change" +%s)

  if [ "$last_commit_date_sec" -ne "0" ] && [ "$last_commit_date_sec" -gt "$last_file_change_sec" ]; then
    read -r -p "Newer version is available, do you want to update (yes/No)? " answer
    case ${answer:0:1} in
    y | Y)
      run_self_update
      ;;
    *)
      return 0
      ;;
    esac
  fi
}
[ -z $CI ] && check_update

tmp_env=$(mktemp)
env | grep -v -e ^PATH= -e ^HOME= -e ^USER= -e ^TMPDIR= >$tmp_env

cat >>$tmp_env <<EOF
SHELL=${path_to_exec_shell}
OTOMI_TAG=${OTOMI_TAG}
OTOMI_CALLER_COMMAND=${BASH_SOURCE[0]##*/}
OTOMI_IN_DOCKER=true
EOF

helm_config="$HOME/.config/helm"
uname -a | grep -i darwin >/dev/null && helm_config="$HOME/Library/Preferences/helm"

stack_dir='/home/app/stack'
executable="node --experimental-specifier-resolution=node ${stack_dir}/dist/otomi.js --"

function mount_with_named_volume() {
  source=$1
  dest=$2
  [ -z "$NAMED_VOLUME" ] && export NAMED_VOLUME='otomi-volume'
  helper_container_name="otomi-volume-helper"

  [ -z "$source" ] && echo "Error in function 'mount_with_named_volume': source path is empty" 1>&2

  { # Create volume and copy over contents
    docker container inspect $helper_container_name && docker rm $helper_container_name
    docker container create --name $helper_container_name -v "$NAMED_VOLUME:$dest" hello-world &&
      cd "$source" && docker cp . "$helper_container_name:$dest" &&
      docker rm $helper_container_name
  } >/dev/null 2>&1

  echo "$NAMED_VOLUME:$dest"
}

stack_volume=""
tmp_volume=""
if [[ $base_dir == *"otomi-core"* ]] || [[ $(pwd) == *"otomi-core"* ]]; then
  if [[ $base_dir == *"otomi-core"* ]]; then
    stack_dir=$(cd "$base_dir/.." && pwd)
  elif [[ $(pwd) == *"otomi-core"* ]]; then
    stack_dir=$(pwd | awk -F'otomi-core' '{print $1"otomi-core"}')
  fi

  stack_volume="-v$(mount_with_named_volume "$stack_dir" "$stack_dir")"
  tmp_volume="-v$(mount_with_named_volume /tmp /tmp)"

  if [ -f "${stack_dir}/dist/otomi.js" ]; then # Use development distribution if exists
    executable="node --experimental-specifier-resolution=node ${stack_dir}/dist/otomi.js --"
  fi
  echo "OTOMI_DEV=true" >>$tmp_env
fi

cmd="${executable} $*"
if [ "$1" = "bash" ] && [ "$#" = "1" ]; then # If command is "otomi bash"
  cmd="bash"
fi

pull_output=$(docker pull $otomi_tools_image 2>&1 >/dev/null)
status=$?
if [ "$status" -ne 0 ]; then
  echo "$pull_output"
  echo "Could not find an image for the supplied OTOMI_TAG: '${OTOMI_TAG}'"
  exit $status
fi

docker run --network host --rm -it \
  "$stack_volume" \
  "$tmp_volume" \
  -v $(mount_with_named_volume /tmp /tmp) \
  -v $(mount_with_named_volume "${KUBECONFIG:-$HOME/.kube}" /home/app/.kube) \
  -v $(mount_with_named_volume "$HOME/.ssh" /home/app/.ssh) \
  -v $(mount_with_named_volume "$helm_config" /home/app/.config/helm) \
  -v $(mount_with_named_volume "$HOME/.config/gcloud" /home/app/.config/gcloud) \
  -v $(mount_with_named_volume "$HOME/.aws" /home/app/.aws) \
  -v $(mount_with_named_volume "$HOME/.azure" /home/app/.azure) \
  -v $(mount_with_named_volume "$ENV_DIR" "$stack_dir/env") \
  -v $(mount_with_named_volume "$ENV_DIR" "$ENV_DIR") \
  --env-file "$tmp_env" \
  -w "$stack_dir" \
  "$otomi_tools_image" \
  bash -c "$cmd"

status=$?
rm -f "$tmp_env"

# Named volume stuff
docker volume rm $NAMED_VOLUME >/dev/null 2>&1
docker rmi hello-world >dev/null 2>&1

exit $status
